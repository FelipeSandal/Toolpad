/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/readdir-glob@1.1.3";
exports.ids = ["vendor-chunks/readdir-glob@1.1.3"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/readdir-glob@1.1.3/node_modules/readdir-glob/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/readdir-glob@1.1.3/node_modules/readdir-glob/index.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = readdirGlob;\n\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { EventEmitter } = __webpack_require__(/*! events */ \"events\");\nconst { Minimatch } = __webpack_require__(/*! minimatch */ \"(ssr)/./node_modules/.pnpm/minimatch@5.1.6/node_modules/minimatch/minimatch.js\");\nconst { resolve } = __webpack_require__(/*! path */ \"path\");\n\nfunction readdir(dir, strict) {\n  return new Promise((resolve, reject) => {\n    fs.readdir(dir, {withFileTypes: true} ,(err, files) => {\n      if(err) {\n        switch (err.code) {\n          case 'ENOTDIR':      // Not a directory\n            if(strict) {\n              reject(err);\n            } else {\n              resolve([]);\n            }\n            break;\n          case 'ENOTSUP':      // Operation not supported\n          case 'ENOENT':       // No such file or directory\n          case 'ENAMETOOLONG': // Filename too long\n          case 'UNKNOWN':\n            resolve([]);\n            break;\n          case 'ELOOP':        // Too many levels of symbolic links\n          default:\n            reject(err);\n            break;\n        }\n      } else {\n        resolve(files);\n      }\n    });\n  });\n}\nfunction stat(file, followSymlinks) {\n  return new Promise((resolve, reject) => {\n    const statFunc = followSymlinks ? fs.stat : fs.lstat;\n    statFunc(file, (err, stats) => {\n      if(err) {\n        switch (err.code) {\n          case 'ENOENT':\n            if(followSymlinks) {\n              // Fallback to lstat to handle broken links as files\n              resolve(stat(file, false)); \n            } else {\n              resolve(null);\n            }\n            break;\n          default:\n            resolve(null);\n            break;\n        }\n      } else {\n        resolve(stats);\n      }\n    });\n  });\n}\n\nasync function* exploreWalkAsync(dir, path, followSymlinks, useStat, shouldSkip, strict) {\n  let files = await readdir(path + dir, strict);\n  for(const file of files) {\n    let name = file.name;\n    if(name === undefined) {\n      // undefined file.name means the `withFileTypes` options is not supported by node\n      // we have to call the stat function to know if file is directory or not.\n      name = file;\n      useStat = true;\n    }\n    const filename = dir + '/' + name;\n    const relative = filename.slice(1); // Remove the leading /\n    const absolute = path + '/' + relative;\n    let stats = null;\n    if(useStat || followSymlinks) {\n      stats = await stat(absolute, followSymlinks);\n    }\n    if(!stats && file.name !== undefined) {\n      stats = file;\n    }\n    if(stats === null) {\n      stats = { isDirectory: () => false };\n    }\n\n    if(stats.isDirectory()) {\n      if(!shouldSkip(relative)) {\n        yield {relative, absolute, stats};\n        yield* exploreWalkAsync(filename, path, followSymlinks, useStat, shouldSkip, false);\n      }\n    } else {\n      yield {relative, absolute, stats};\n    }\n  }\n}\nasync function* explore(path, followSymlinks, useStat, shouldSkip) {\n  yield* exploreWalkAsync('', path, followSymlinks, useStat, shouldSkip, true);\n}\n\n\nfunction readOptions(options) {\n  return {\n    pattern: options.pattern,\n    dot: !!options.dot,\n    noglobstar: !!options.noglobstar,\n    matchBase: !!options.matchBase,\n    nocase: !!options.nocase,\n    ignore: options.ignore,\n    skip: options.skip,\n\n    follow: !!options.follow,\n    stat: !!options.stat,\n    nodir: !!options.nodir,\n    mark: !!options.mark,\n    silent: !!options.silent,\n    absolute: !!options.absolute\n  };\n}\n\nclass ReaddirGlob extends EventEmitter {\n  constructor(cwd, options, cb) {\n    super();\n    if(typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.options = readOptions(options ||Â {});\n  \n    this.matchers = [];\n    if(this.options.pattern) {\n      const matchers = Array.isArray(this.options.pattern) ? this.options.pattern : [this.options.pattern];\n      this.matchers = matchers.map( m =>\n        new Minimatch(m, {\n          dot: this.options.dot,\n          noglobstar:this.options.noglobstar,\n          matchBase:this.options.matchBase,\n          nocase:this.options.nocase\n        })\n      );\n    }\n  \n    this.ignoreMatchers = [];\n    if(this.options.ignore) {\n      const ignorePatterns = Array.isArray(this.options.ignore) ? this.options.ignore : [this.options.ignore];\n      this.ignoreMatchers = ignorePatterns.map( ignore =>\n        new Minimatch(ignore, {dot: true})\n      );\n    }\n  \n    this.skipMatchers = [];\n    if(this.options.skip) {\n      const skipPatterns = Array.isArray(this.options.skip) ? this.options.skip : [this.options.skip];\n      this.skipMatchers = skipPatterns.map( skip =>\n        new Minimatch(skip, {dot: true})\n      );\n    }\n\n    this.iterator = explore(resolve(cwd || '.'), this.options.follow, this.options.stat, this._shouldSkipDirectory.bind(this));\n    this.paused = false;\n    this.inactive = false;\n    this.aborted = false;\n  \n    if(cb) {\n      this._matches = []; \n      this.on('match', match => this._matches.push(this.options.absolute ? match.absolute : match.relative));\n      this.on('error', err => cb(err));\n      this.on('end', () => cb(null, this._matches));\n    }\n\n    setTimeout( () => this._next(), 0);\n  }\n\n  _shouldSkipDirectory(relative) {\n    //console.log(relative, this.skipMatchers.some(m => m.match(relative)));\n    return this.skipMatchers.some(m => m.match(relative));\n  }\n\n  _fileMatches(relative, isDirectory) {\n    const file = relative + (isDirectory ? '/' : '');\n    return (this.matchers.length === 0 || this.matchers.some(m => m.match(file)))\n      && !this.ignoreMatchers.some(m => m.match(file))\n      && (!this.options.nodir || !isDirectory);\n  }\n\n  _next() {\n    if(!this.paused && !this.aborted) {\n      this.iterator.next()\n      .then((obj)=> {\n        if(!obj.done) {\n          const isDirectory = obj.value.stats.isDirectory();\n          if(this._fileMatches(obj.value.relative, isDirectory )) {\n            let relative = obj.value.relative;\n            let absolute = obj.value.absolute;\n            if(this.options.mark && isDirectory) {\n              relative += '/';\n              absolute += '/';\n            }\n            if(this.options.stat) {\n              this.emit('match', {relative, absolute, stat:obj.value.stats});\n            } else {\n              this.emit('match', {relative, absolute});\n            }\n          }\n          this._next(this.iterator);\n        } else {\n          this.emit('end');\n        }\n      })\n      .catch((err) => {\n        this.abort();\n        this.emit('error', err);\n        if(!err.code && !this.options.silent) {\n          console.error(err);\n        }\n      });\n    } else {\n      this.inactive = true;\n    }\n  }\n\n  abort() {\n    this.aborted = true;\n  }\n\n  pause() {\n    this.paused = true;\n  }\n\n  resume() {\n    this.paused = false;\n    if(this.inactive) {\n      this.inactive = false;\n      this._next();\n    }\n  }\n}\n\n\nfunction readdirGlob(pattern, options, cb) {\n  return new ReaddirGlob(pattern, options, cb);\n}\nreaddirGlob.ReaddirGlob = ReaddirGlob;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhZGRpci1nbG9iQDEuMS4zL25vZGVfbW9kdWxlcy9yZWFkZGlyLWdsb2IvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsUUFBUSxlQUFlLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUN6QyxRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLGlHQUFXO0FBQ3pDLFFBQVEsVUFBVSxFQUFFLG1CQUFPLENBQUMsa0JBQU07O0FBRWxDO0FBQ0E7QUFDQSxxQkFBcUIscUJBQXFCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLE1BQU07QUFDTixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsVUFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixVQUFVO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHlDQUF5QztBQUMzRSxjQUFjO0FBQ2Qsa0NBQWtDLG1CQUFtQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxlbmlhXFxEb3dubG9hZHNcXFRvb2xwYWQtMlxcbm9kZV9tb2R1bGVzXFwucG5wbVxccmVhZGRpci1nbG9iQDEuMS4zXFxub2RlX21vZHVsZXNcXHJlYWRkaXItZ2xvYlxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZWFkZGlyR2xvYjtcblxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgeyBFdmVudEVtaXR0ZXIgfSA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgeyBNaW5pbWF0Y2ggfSA9IHJlcXVpcmUoJ21pbmltYXRjaCcpO1xuY29uc3QgeyByZXNvbHZlIH0gPSByZXF1aXJlKCdwYXRoJyk7XG5cbmZ1bmN0aW9uIHJlYWRkaXIoZGlyLCBzdHJpY3QpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmcy5yZWFkZGlyKGRpciwge3dpdGhGaWxlVHlwZXM6IHRydWV9ICwoZXJyLCBmaWxlcykgPT4ge1xuICAgICAgaWYoZXJyKSB7XG4gICAgICAgIHN3aXRjaCAoZXJyLmNvZGUpIHtcbiAgICAgICAgICBjYXNlICdFTk9URElSJzogICAgICAvLyBOb3QgYSBkaXJlY3RvcnlcbiAgICAgICAgICAgIGlmKHN0cmljdCkge1xuICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnRU5PVFNVUCc6ICAgICAgLy8gT3BlcmF0aW9uIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICBjYXNlICdFTk9FTlQnOiAgICAgICAvLyBObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XG4gICAgICAgICAgY2FzZSAnRU5BTUVUT09MT05HJzogLy8gRmlsZW5hbWUgdG9vIGxvbmdcbiAgICAgICAgICBjYXNlICdVTktOT1dOJzpcbiAgICAgICAgICAgIHJlc29sdmUoW10pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnRUxPT1AnOiAgICAgICAgLy8gVG9vIG1hbnkgbGV2ZWxzIG9mIHN5bWJvbGljIGxpbmtzXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUoZmlsZXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHN0YXQoZmlsZSwgZm9sbG93U3ltbGlua3MpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBzdGF0RnVuYyA9IGZvbGxvd1N5bWxpbmtzID8gZnMuc3RhdCA6IGZzLmxzdGF0O1xuICAgIHN0YXRGdW5jKGZpbGUsIChlcnIsIHN0YXRzKSA9PiB7XG4gICAgICBpZihlcnIpIHtcbiAgICAgICAgc3dpdGNoIChlcnIuY29kZSkge1xuICAgICAgICAgIGNhc2UgJ0VOT0VOVCc6XG4gICAgICAgICAgICBpZihmb2xsb3dTeW1saW5rcykge1xuICAgICAgICAgICAgICAvLyBGYWxsYmFjayB0byBsc3RhdCB0byBoYW5kbGUgYnJva2VuIGxpbmtzIGFzIGZpbGVzXG4gICAgICAgICAgICAgIHJlc29sdmUoc3RhdChmaWxlLCBmYWxzZSkpOyBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKHN0YXRzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uKiBleHBsb3JlV2Fsa0FzeW5jKGRpciwgcGF0aCwgZm9sbG93U3ltbGlua3MsIHVzZVN0YXQsIHNob3VsZFNraXAsIHN0cmljdCkge1xuICBsZXQgZmlsZXMgPSBhd2FpdCByZWFkZGlyKHBhdGggKyBkaXIsIHN0cmljdCk7XG4gIGZvcihjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgbGV0IG5hbWUgPSBmaWxlLm5hbWU7XG4gICAgaWYobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyB1bmRlZmluZWQgZmlsZS5uYW1lIG1lYW5zIHRoZSBgd2l0aEZpbGVUeXBlc2Agb3B0aW9ucyBpcyBub3Qgc3VwcG9ydGVkIGJ5IG5vZGVcbiAgICAgIC8vIHdlIGhhdmUgdG8gY2FsbCB0aGUgc3RhdCBmdW5jdGlvbiB0byBrbm93IGlmIGZpbGUgaXMgZGlyZWN0b3J5IG9yIG5vdC5cbiAgICAgIG5hbWUgPSBmaWxlO1xuICAgICAgdXNlU3RhdCA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGZpbGVuYW1lID0gZGlyICsgJy8nICsgbmFtZTtcbiAgICBjb25zdCByZWxhdGl2ZSA9IGZpbGVuYW1lLnNsaWNlKDEpOyAvLyBSZW1vdmUgdGhlIGxlYWRpbmcgL1xuICAgIGNvbnN0IGFic29sdXRlID0gcGF0aCArICcvJyArIHJlbGF0aXZlO1xuICAgIGxldCBzdGF0cyA9IG51bGw7XG4gICAgaWYodXNlU3RhdCB8fCBmb2xsb3dTeW1saW5rcykge1xuICAgICAgc3RhdHMgPSBhd2FpdCBzdGF0KGFic29sdXRlLCBmb2xsb3dTeW1saW5rcyk7XG4gICAgfVxuICAgIGlmKCFzdGF0cyAmJiBmaWxlLm5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc3RhdHMgPSBmaWxlO1xuICAgIH1cbiAgICBpZihzdGF0cyA9PT0gbnVsbCkge1xuICAgICAgc3RhdHMgPSB7IGlzRGlyZWN0b3J5OiAoKSA9PiBmYWxzZSB9O1xuICAgIH1cblxuICAgIGlmKHN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIGlmKCFzaG91bGRTa2lwKHJlbGF0aXZlKSkge1xuICAgICAgICB5aWVsZCB7cmVsYXRpdmUsIGFic29sdXRlLCBzdGF0c307XG4gICAgICAgIHlpZWxkKiBleHBsb3JlV2Fsa0FzeW5jKGZpbGVuYW1lLCBwYXRoLCBmb2xsb3dTeW1saW5rcywgdXNlU3RhdCwgc2hvdWxkU2tpcCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB5aWVsZCB7cmVsYXRpdmUsIGFic29sdXRlLCBzdGF0c307XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiogZXhwbG9yZShwYXRoLCBmb2xsb3dTeW1saW5rcywgdXNlU3RhdCwgc2hvdWxkU2tpcCkge1xuICB5aWVsZCogZXhwbG9yZVdhbGtBc3luYygnJywgcGF0aCwgZm9sbG93U3ltbGlua3MsIHVzZVN0YXQsIHNob3VsZFNraXAsIHRydWUpO1xufVxuXG5cbmZ1bmN0aW9uIHJlYWRPcHRpb25zKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBwYXR0ZXJuOiBvcHRpb25zLnBhdHRlcm4sXG4gICAgZG90OiAhIW9wdGlvbnMuZG90LFxuICAgIG5vZ2xvYnN0YXI6ICEhb3B0aW9ucy5ub2dsb2JzdGFyLFxuICAgIG1hdGNoQmFzZTogISFvcHRpb25zLm1hdGNoQmFzZSxcbiAgICBub2Nhc2U6ICEhb3B0aW9ucy5ub2Nhc2UsXG4gICAgaWdub3JlOiBvcHRpb25zLmlnbm9yZSxcbiAgICBza2lwOiBvcHRpb25zLnNraXAsXG5cbiAgICBmb2xsb3c6ICEhb3B0aW9ucy5mb2xsb3csXG4gICAgc3RhdDogISFvcHRpb25zLnN0YXQsXG4gICAgbm9kaXI6ICEhb3B0aW9ucy5ub2RpcixcbiAgICBtYXJrOiAhIW9wdGlvbnMubWFyayxcbiAgICBzaWxlbnQ6ICEhb3B0aW9ucy5zaWxlbnQsXG4gICAgYWJzb2x1dGU6ICEhb3B0aW9ucy5hYnNvbHV0ZVxuICB9O1xufVxuXG5jbGFzcyBSZWFkZGlyR2xvYiBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKGN3ZCwgb3B0aW9ucywgY2IpIHtcbiAgICBzdXBlcigpO1xuICAgIGlmKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSByZWFkT3B0aW9ucyhvcHRpb25zIHx8wqB7fSk7XG4gIFxuICAgIHRoaXMubWF0Y2hlcnMgPSBbXTtcbiAgICBpZih0aGlzLm9wdGlvbnMucGF0dGVybikge1xuICAgICAgY29uc3QgbWF0Y2hlcnMgPSBBcnJheS5pc0FycmF5KHRoaXMub3B0aW9ucy5wYXR0ZXJuKSA/IHRoaXMub3B0aW9ucy5wYXR0ZXJuIDogW3RoaXMub3B0aW9ucy5wYXR0ZXJuXTtcbiAgICAgIHRoaXMubWF0Y2hlcnMgPSBtYXRjaGVycy5tYXAoIG0gPT5cbiAgICAgICAgbmV3IE1pbmltYXRjaChtLCB7XG4gICAgICAgICAgZG90OiB0aGlzLm9wdGlvbnMuZG90LFxuICAgICAgICAgIG5vZ2xvYnN0YXI6dGhpcy5vcHRpb25zLm5vZ2xvYnN0YXIsXG4gICAgICAgICAgbWF0Y2hCYXNlOnRoaXMub3B0aW9ucy5tYXRjaEJhc2UsXG4gICAgICAgICAgbm9jYXNlOnRoaXMub3B0aW9ucy5ub2Nhc2VcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICBcbiAgICB0aGlzLmlnbm9yZU1hdGNoZXJzID0gW107XG4gICAgaWYodGhpcy5vcHRpb25zLmlnbm9yZSkge1xuICAgICAgY29uc3QgaWdub3JlUGF0dGVybnMgPSBBcnJheS5pc0FycmF5KHRoaXMub3B0aW9ucy5pZ25vcmUpID8gdGhpcy5vcHRpb25zLmlnbm9yZSA6IFt0aGlzLm9wdGlvbnMuaWdub3JlXTtcbiAgICAgIHRoaXMuaWdub3JlTWF0Y2hlcnMgPSBpZ25vcmVQYXR0ZXJucy5tYXAoIGlnbm9yZSA9PlxuICAgICAgICBuZXcgTWluaW1hdGNoKGlnbm9yZSwge2RvdDogdHJ1ZX0pXG4gICAgICApO1xuICAgIH1cbiAgXG4gICAgdGhpcy5za2lwTWF0Y2hlcnMgPSBbXTtcbiAgICBpZih0aGlzLm9wdGlvbnMuc2tpcCkge1xuICAgICAgY29uc3Qgc2tpcFBhdHRlcm5zID0gQXJyYXkuaXNBcnJheSh0aGlzLm9wdGlvbnMuc2tpcCkgPyB0aGlzLm9wdGlvbnMuc2tpcCA6IFt0aGlzLm9wdGlvbnMuc2tpcF07XG4gICAgICB0aGlzLnNraXBNYXRjaGVycyA9IHNraXBQYXR0ZXJucy5tYXAoIHNraXAgPT5cbiAgICAgICAgbmV3IE1pbmltYXRjaChza2lwLCB7ZG90OiB0cnVlfSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5pdGVyYXRvciA9IGV4cGxvcmUocmVzb2x2ZShjd2QgfHwgJy4nKSwgdGhpcy5vcHRpb25zLmZvbGxvdywgdGhpcy5vcHRpb25zLnN0YXQsIHRoaXMuX3Nob3VsZFNraXBEaXJlY3RvcnkuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmluYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5hYm9ydGVkID0gZmFsc2U7XG4gIFxuICAgIGlmKGNiKSB7XG4gICAgICB0aGlzLl9tYXRjaGVzID0gW107IFxuICAgICAgdGhpcy5vbignbWF0Y2gnLCBtYXRjaCA9PiB0aGlzLl9tYXRjaGVzLnB1c2godGhpcy5vcHRpb25zLmFic29sdXRlID8gbWF0Y2guYWJzb2x1dGUgOiBtYXRjaC5yZWxhdGl2ZSkpO1xuICAgICAgdGhpcy5vbignZXJyb3InLCBlcnIgPT4gY2IoZXJyKSk7XG4gICAgICB0aGlzLm9uKCdlbmQnLCAoKSA9PiBjYihudWxsLCB0aGlzLl9tYXRjaGVzKSk7XG4gICAgfVxuXG4gICAgc2V0VGltZW91dCggKCkgPT4gdGhpcy5fbmV4dCgpLCAwKTtcbiAgfVxuXG4gIF9zaG91bGRTa2lwRGlyZWN0b3J5KHJlbGF0aXZlKSB7XG4gICAgLy9jb25zb2xlLmxvZyhyZWxhdGl2ZSwgdGhpcy5za2lwTWF0Y2hlcnMuc29tZShtID0+IG0ubWF0Y2gocmVsYXRpdmUpKSk7XG4gICAgcmV0dXJuIHRoaXMuc2tpcE1hdGNoZXJzLnNvbWUobSA9PiBtLm1hdGNoKHJlbGF0aXZlKSk7XG4gIH1cblxuICBfZmlsZU1hdGNoZXMocmVsYXRpdmUsIGlzRGlyZWN0b3J5KSB7XG4gICAgY29uc3QgZmlsZSA9IHJlbGF0aXZlICsgKGlzRGlyZWN0b3J5ID8gJy8nIDogJycpO1xuICAgIHJldHVybiAodGhpcy5tYXRjaGVycy5sZW5ndGggPT09IDAgfHwgdGhpcy5tYXRjaGVycy5zb21lKG0gPT4gbS5tYXRjaChmaWxlKSkpXG4gICAgICAmJiAhdGhpcy5pZ25vcmVNYXRjaGVycy5zb21lKG0gPT4gbS5tYXRjaChmaWxlKSlcbiAgICAgICYmICghdGhpcy5vcHRpb25zLm5vZGlyIHx8ICFpc0RpcmVjdG9yeSk7XG4gIH1cblxuICBfbmV4dCgpIHtcbiAgICBpZighdGhpcy5wYXVzZWQgJiYgIXRoaXMuYWJvcnRlZCkge1xuICAgICAgdGhpcy5pdGVyYXRvci5uZXh0KClcbiAgICAgIC50aGVuKChvYmopPT4ge1xuICAgICAgICBpZighb2JqLmRvbmUpIHtcbiAgICAgICAgICBjb25zdCBpc0RpcmVjdG9yeSA9IG9iai52YWx1ZS5zdGF0cy5pc0RpcmVjdG9yeSgpO1xuICAgICAgICAgIGlmKHRoaXMuX2ZpbGVNYXRjaGVzKG9iai52YWx1ZS5yZWxhdGl2ZSwgaXNEaXJlY3RvcnkgKSkge1xuICAgICAgICAgICAgbGV0IHJlbGF0aXZlID0gb2JqLnZhbHVlLnJlbGF0aXZlO1xuICAgICAgICAgICAgbGV0IGFic29sdXRlID0gb2JqLnZhbHVlLmFic29sdXRlO1xuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLm1hcmsgJiYgaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgICAgICAgcmVsYXRpdmUgKz0gJy8nO1xuICAgICAgICAgICAgICBhYnNvbHV0ZSArPSAnLyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuc3RhdCkge1xuICAgICAgICAgICAgICB0aGlzLmVtaXQoJ21hdGNoJywge3JlbGF0aXZlLCBhYnNvbHV0ZSwgc3RhdDpvYmoudmFsdWUuc3RhdHN9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuZW1pdCgnbWF0Y2gnLCB7cmVsYXRpdmUsIGFic29sdXRlfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX25leHQodGhpcy5pdGVyYXRvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdlbmQnKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIHRoaXMuYWJvcnQoKTtcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgIGlmKCFlcnIuY29kZSAmJiAhdGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaW5hY3RpdmUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGFib3J0KCkge1xuICAgIHRoaXMuYWJvcnRlZCA9IHRydWU7XG4gIH1cblxuICBwYXVzZSgpIHtcbiAgICB0aGlzLnBhdXNlZCA9IHRydWU7XG4gIH1cblxuICByZXN1bWUoKSB7XG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICBpZih0aGlzLmluYWN0aXZlKSB7XG4gICAgICB0aGlzLmluYWN0aXZlID0gZmFsc2U7XG4gICAgICB0aGlzLl9uZXh0KCk7XG4gICAgfVxuICB9XG59XG5cblxuZnVuY3Rpb24gcmVhZGRpckdsb2IocGF0dGVybiwgb3B0aW9ucywgY2IpIHtcbiAgcmV0dXJuIG5ldyBSZWFkZGlyR2xvYihwYXR0ZXJuLCBvcHRpb25zLCBjYik7XG59XG5yZWFkZGlyR2xvYi5SZWFkZGlyR2xvYiA9IFJlYWRkaXJHbG9iOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/readdir-glob@1.1.3/node_modules/readdir-glob/index.js\n");

/***/ })

};
;