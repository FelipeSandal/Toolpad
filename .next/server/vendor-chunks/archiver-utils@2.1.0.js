/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/archiver-utils@2.1.0";
exports.ids = ["vendor-chunks/archiver-utils@2.1.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/archiver-utils@2.1.0/node_modules/archiver-utils/file.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.pnpm/archiver-utils@2.1.0/node_modules/archiver-utils/file.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\r\n * archiver-utils\r\n *\r\n * Copyright (c) 2012-2014 Chris Talkington, contributors.\r\n * Licensed under the MIT license.\r\n * https://github.com/archiverjs/node-archiver/blob/master/LICENSE-MIT\r\n */\r\nvar fs = __webpack_require__(/*! graceful-fs */ \"(ssr)/./node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/graceful-fs.js\");\r\nvar path = __webpack_require__(/*! path */ \"path\");\r\n\r\nvar flatten = __webpack_require__(/*! lodash.flatten */ \"(ssr)/./node_modules/.pnpm/lodash.flatten@4.4.0/node_modules/lodash.flatten/index.js\");\r\nvar difference = __webpack_require__(/*! lodash.difference */ \"(ssr)/./node_modules/.pnpm/lodash.difference@4.5.0/node_modules/lodash.difference/index.js\");\r\nvar union = __webpack_require__(/*! lodash.union */ \"(ssr)/./node_modules/.pnpm/lodash.union@4.6.0/node_modules/lodash.union/index.js\");\r\nvar isPlainObject = __webpack_require__(/*! lodash.isplainobject */ \"(ssr)/./node_modules/.pnpm/lodash.isplainobject@4.0.6/node_modules/lodash.isplainobject/index.js\");\r\n\r\nvar glob = __webpack_require__(/*! glob */ \"(ssr)/./node_modules/.pnpm/glob@7.2.3/node_modules/glob/glob.js\");\r\n\r\nvar file = module.exports = {};\r\n\r\nvar pathSeparatorRe = /[\\/\\\\]/g;\r\n\r\n// Process specified wildcard glob patterns or filenames against a\r\n// callback, excluding and uniquing files in the result set.\r\nvar processPatterns = function(patterns, fn) {\r\n  // Filepaths to return.\r\n  var result = [];\r\n  // Iterate over flattened patterns array.\r\n  flatten(patterns).forEach(function(pattern) {\r\n    // If the first character is ! it should be omitted\r\n    var exclusion = pattern.indexOf('!') === 0;\r\n    // If the pattern is an exclusion, remove the !\r\n    if (exclusion) { pattern = pattern.slice(1); }\r\n    // Find all matching files for this pattern.\r\n    var matches = fn(pattern);\r\n    if (exclusion) {\r\n      // If an exclusion, remove matching files.\r\n      result = difference(result, matches);\r\n    } else {\r\n      // Otherwise add matching files.\r\n      result = union(result, matches);\r\n    }\r\n  });\r\n  return result;\r\n};\r\n\r\n// True if the file path exists.\r\nfile.exists = function() {\r\n  var filepath = path.join.apply(path, arguments);\r\n  return fs.existsSync(filepath);\r\n};\r\n\r\n// Return an array of all file paths that match the given wildcard patterns.\r\nfile.expand = function(...args) {\r\n  // If the first argument is an options object, save those options to pass\r\n  // into the File.prototype.glob.sync method.\r\n  var options = isPlainObject(args[0]) ? args.shift() : {};\r\n  // Use the first argument if it's an Array, otherwise convert the arguments\r\n  // object to an array and use that.\r\n  var patterns = Array.isArray(args[0]) ? args[0] : args;\r\n  // Return empty set if there are no patterns or filepaths.\r\n  if (patterns.length === 0) { return []; }\r\n  // Return all matching filepaths.\r\n  var matches = processPatterns(patterns, function(pattern) {\r\n    // Find all matching files for this pattern.\r\n    return glob.sync(pattern, options);\r\n  });\r\n  // Filter result set?\r\n  if (options.filter) {\r\n    matches = matches.filter(function(filepath) {\r\n      filepath = path.join(options.cwd || '', filepath);\r\n      try {\r\n        if (typeof options.filter === 'function') {\r\n          return options.filter(filepath);\r\n        } else {\r\n          // If the file is of the right type and exists, this should work.\r\n          return fs.statSync(filepath)[options.filter]();\r\n        }\r\n      } catch(e) {\r\n        // Otherwise, it's probably not the right type.\r\n        return false;\r\n      }\r\n    });\r\n  }\r\n  return matches;\r\n};\r\n\r\n// Build a multi task \"files\" object dynamically.\r\nfile.expandMapping = function(patterns, destBase, options) {\r\n  options = Object.assign({\r\n    rename: function(destBase, destPath) {\r\n      return path.join(destBase || '', destPath);\r\n    }\r\n  }, options);\r\n  var files = [];\r\n  var fileByDest = {};\r\n  // Find all files matching pattern, using passed-in options.\r\n  file.expand(options, patterns).forEach(function(src) {\r\n    var destPath = src;\r\n    // Flatten?\r\n    if (options.flatten) {\r\n      destPath = path.basename(destPath);\r\n    }\r\n    // Change the extension?\r\n    if (options.ext) {\r\n      destPath = destPath.replace(/(\\.[^\\/]*)?$/, options.ext);\r\n    }\r\n    // Generate destination filename.\r\n    var dest = options.rename(destBase, destPath, options);\r\n    // Prepend cwd to src path if necessary.\r\n    if (options.cwd) { src = path.join(options.cwd, src); }\r\n    // Normalize filepaths to be unix-style.\r\n    dest = dest.replace(pathSeparatorRe, '/');\r\n    src = src.replace(pathSeparatorRe, '/');\r\n    // Map correct src path to dest path.\r\n    if (fileByDest[dest]) {\r\n      // If dest already exists, push this src onto that dest's src array.\r\n      fileByDest[dest].src.push(src);\r\n    } else {\r\n      // Otherwise create a new src-dest file mapping object.\r\n      files.push({\r\n        src: [src],\r\n        dest: dest,\r\n      });\r\n      // And store a reference for later use.\r\n      fileByDest[dest] = files[files.length - 1];\r\n    }\r\n  });\r\n  return files;\r\n};\r\n\r\n// reusing bits of grunt's multi-task source normalization\r\nfile.normalizeFilesArray = function(data) {\r\n  var files = [];\r\n\r\n  data.forEach(function(obj) {\r\n    var prop;\r\n    if ('src' in obj || 'dest' in obj) {\r\n      files.push(obj);\r\n    }\r\n  });\r\n\r\n  if (files.length === 0) {\r\n    return [];\r\n  }\r\n\r\n  files = _(files).chain().forEach(function(obj) {\r\n    if (!('src' in obj) || !obj.src) { return; }\r\n    // Normalize .src properties to flattened array.\r\n    if (Array.isArray(obj.src)) {\r\n      obj.src = flatten(obj.src);\r\n    } else {\r\n      obj.src = [obj.src];\r\n    }\r\n  }).map(function(obj) {\r\n    // Build options object, removing unwanted properties.\r\n    var expandOptions = Object.assign({}, obj);\r\n    delete expandOptions.src;\r\n    delete expandOptions.dest;\r\n\r\n    // Expand file mappings.\r\n    if (obj.expand) {\r\n      return file.expandMapping(obj.src, obj.dest, expandOptions).map(function(mapObj) {\r\n        // Copy obj properties to result.\r\n        var result = Object.assign({}, obj);\r\n        // Make a clone of the orig obj available.\r\n        result.orig = Object.assign({}, obj);\r\n        // Set .src and .dest, processing both as templates.\r\n        result.src = mapObj.src;\r\n        result.dest = mapObj.dest;\r\n        // Remove unwanted properties.\r\n        ['expand', 'cwd', 'flatten', 'rename', 'ext'].forEach(function(prop) {\r\n          delete result[prop];\r\n        });\r\n        return result;\r\n      });\r\n    }\r\n\r\n    // Copy obj properties to result, adding an .orig property.\r\n    var result = Object.assign({}, obj);\r\n    // Make a clone of the orig obj available.\r\n    result.orig = Object.assign({}, obj);\r\n\r\n    if ('src' in result) {\r\n      // Expose an expand-on-demand getter method as .src.\r\n      Object.defineProperty(result, 'src', {\r\n        enumerable: true,\r\n        get: function fn() {\r\n          var src;\r\n          if (!('result' in fn)) {\r\n            src = obj.src;\r\n            // If src is an array, flatten it. Otherwise, make it into an array.\r\n            src = Array.isArray(src) ? flatten(src) : [src];\r\n            // Expand src files, memoizing result.\r\n            fn.result = file.expand(expandOptions, src);\r\n          }\r\n          return fn.result;\r\n        }\r\n      });\r\n    }\r\n\r\n    if ('dest' in result) {\r\n      result.dest = obj.dest;\r\n    }\r\n\r\n    return result;\r\n  }).flatten().value();\r\n\r\n  return files;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYXJjaGl2ZXItdXRpbHNAMi4xLjAvbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL2ZpbGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1CQUFPLENBQUMsMEdBQWE7QUFDOUIsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLDRHQUFnQjtBQUN0QyxpQkFBaUIsbUJBQU8sQ0FBQyxxSEFBbUI7QUFDNUMsWUFBWSxtQkFBTyxDQUFDLHNHQUFjO0FBQ2xDLG9CQUFvQixtQkFBTyxDQUFDLDhIQUFzQjtBQUNsRDtBQUNBLFdBQVcsbUJBQU8sQ0FBQyw2RUFBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbGVuaWFcXERvd25sb2Fkc1xcVG9vbHBhZC0yXFxub2RlX21vZHVsZXNcXC5wbnBtXFxhcmNoaXZlci11dGlsc0AyLjEuMFxcbm9kZV9tb2R1bGVzXFxhcmNoaXZlci11dGlsc1xcZmlsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogYXJjaGl2ZXItdXRpbHNcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQgQ2hyaXMgVGFsa2luZ3RvbiwgY29udHJpYnV0b3JzLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hcmNoaXZlcmpzL25vZGUtYXJjaGl2ZXIvYmxvYi9tYXN0ZXIvTElDRU5TRS1NSVRcclxuICovXHJcbnZhciBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJyk7XHJcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xyXG5cclxudmFyIGZsYXR0ZW4gPSByZXF1aXJlKCdsb2Rhc2guZmxhdHRlbicpO1xyXG52YXIgZGlmZmVyZW5jZSA9IHJlcXVpcmUoJ2xvZGFzaC5kaWZmZXJlbmNlJyk7XHJcbnZhciB1bmlvbiA9IHJlcXVpcmUoJ2xvZGFzaC51bmlvbicpO1xyXG52YXIgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJ2xvZGFzaC5pc3BsYWlub2JqZWN0Jyk7XHJcblxyXG52YXIgZ2xvYiA9IHJlcXVpcmUoJ2dsb2InKTtcclxuXHJcbnZhciBmaWxlID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcclxuXHJcbnZhciBwYXRoU2VwYXJhdG9yUmUgPSAvW1xcL1xcXFxdL2c7XHJcblxyXG4vLyBQcm9jZXNzIHNwZWNpZmllZCB3aWxkY2FyZCBnbG9iIHBhdHRlcm5zIG9yIGZpbGVuYW1lcyBhZ2FpbnN0IGFcclxuLy8gY2FsbGJhY2ssIGV4Y2x1ZGluZyBhbmQgdW5pcXVpbmcgZmlsZXMgaW4gdGhlIHJlc3VsdCBzZXQuXHJcbnZhciBwcm9jZXNzUGF0dGVybnMgPSBmdW5jdGlvbihwYXR0ZXJucywgZm4pIHtcclxuICAvLyBGaWxlcGF0aHMgdG8gcmV0dXJuLlxyXG4gIHZhciByZXN1bHQgPSBbXTtcclxuICAvLyBJdGVyYXRlIG92ZXIgZmxhdHRlbmVkIHBhdHRlcm5zIGFycmF5LlxyXG4gIGZsYXR0ZW4ocGF0dGVybnMpLmZvckVhY2goZnVuY3Rpb24ocGF0dGVybikge1xyXG4gICAgLy8gSWYgdGhlIGZpcnN0IGNoYXJhY3RlciBpcyAhIGl0IHNob3VsZCBiZSBvbWl0dGVkXHJcbiAgICB2YXIgZXhjbHVzaW9uID0gcGF0dGVybi5pbmRleE9mKCchJykgPT09IDA7XHJcbiAgICAvLyBJZiB0aGUgcGF0dGVybiBpcyBhbiBleGNsdXNpb24sIHJlbW92ZSB0aGUgIVxyXG4gICAgaWYgKGV4Y2x1c2lvbikgeyBwYXR0ZXJuID0gcGF0dGVybi5zbGljZSgxKTsgfVxyXG4gICAgLy8gRmluZCBhbGwgbWF0Y2hpbmcgZmlsZXMgZm9yIHRoaXMgcGF0dGVybi5cclxuICAgIHZhciBtYXRjaGVzID0gZm4ocGF0dGVybik7XHJcbiAgICBpZiAoZXhjbHVzaW9uKSB7XHJcbiAgICAgIC8vIElmIGFuIGV4Y2x1c2lvbiwgcmVtb3ZlIG1hdGNoaW5nIGZpbGVzLlxyXG4gICAgICByZXN1bHQgPSBkaWZmZXJlbmNlKHJlc3VsdCwgbWF0Y2hlcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBPdGhlcndpc2UgYWRkIG1hdGNoaW5nIGZpbGVzLlxyXG4gICAgICByZXN1bHQgPSB1bmlvbihyZXN1bHQsIG1hdGNoZXMpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG4vLyBUcnVlIGlmIHRoZSBmaWxlIHBhdGggZXhpc3RzLlxyXG5maWxlLmV4aXN0cyA9IGZ1bmN0aW9uKCkge1xyXG4gIHZhciBmaWxlcGF0aCA9IHBhdGguam9pbi5hcHBseShwYXRoLCBhcmd1bWVudHMpO1xyXG4gIHJldHVybiBmcy5leGlzdHNTeW5jKGZpbGVwYXRoKTtcclxufTtcclxuXHJcbi8vIFJldHVybiBhbiBhcnJheSBvZiBhbGwgZmlsZSBwYXRocyB0aGF0IG1hdGNoIHRoZSBnaXZlbiB3aWxkY2FyZCBwYXR0ZXJucy5cclxuZmlsZS5leHBhbmQgPSBmdW5jdGlvbiguLi5hcmdzKSB7XHJcbiAgLy8gSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGFuIG9wdGlvbnMgb2JqZWN0LCBzYXZlIHRob3NlIG9wdGlvbnMgdG8gcGFzc1xyXG4gIC8vIGludG8gdGhlIEZpbGUucHJvdG90eXBlLmdsb2Iuc3luYyBtZXRob2QuXHJcbiAgdmFyIG9wdGlvbnMgPSBpc1BsYWluT2JqZWN0KGFyZ3NbMF0pID8gYXJncy5zaGlmdCgpIDoge307XHJcbiAgLy8gVXNlIHRoZSBmaXJzdCBhcmd1bWVudCBpZiBpdCdzIGFuIEFycmF5LCBvdGhlcndpc2UgY29udmVydCB0aGUgYXJndW1lbnRzXHJcbiAgLy8gb2JqZWN0IHRvIGFuIGFycmF5IGFuZCB1c2UgdGhhdC5cclxuICB2YXIgcGF0dGVybnMgPSBBcnJheS5pc0FycmF5KGFyZ3NbMF0pID8gYXJnc1swXSA6IGFyZ3M7XHJcbiAgLy8gUmV0dXJuIGVtcHR5IHNldCBpZiB0aGVyZSBhcmUgbm8gcGF0dGVybnMgb3IgZmlsZXBhdGhzLlxyXG4gIGlmIChwYXR0ZXJucy5sZW5ndGggPT09IDApIHsgcmV0dXJuIFtdOyB9XHJcbiAgLy8gUmV0dXJuIGFsbCBtYXRjaGluZyBmaWxlcGF0aHMuXHJcbiAgdmFyIG1hdGNoZXMgPSBwcm9jZXNzUGF0dGVybnMocGF0dGVybnMsIGZ1bmN0aW9uKHBhdHRlcm4pIHtcclxuICAgIC8vIEZpbmQgYWxsIG1hdGNoaW5nIGZpbGVzIGZvciB0aGlzIHBhdHRlcm4uXHJcbiAgICByZXR1cm4gZ2xvYi5zeW5jKHBhdHRlcm4sIG9wdGlvbnMpO1xyXG4gIH0pO1xyXG4gIC8vIEZpbHRlciByZXN1bHQgc2V0P1xyXG4gIGlmIChvcHRpb25zLmZpbHRlcikge1xyXG4gICAgbWF0Y2hlcyA9IG1hdGNoZXMuZmlsdGVyKGZ1bmN0aW9uKGZpbGVwYXRoKSB7XHJcbiAgICAgIGZpbGVwYXRoID0gcGF0aC5qb2luKG9wdGlvbnMuY3dkIHx8ICcnLCBmaWxlcGF0aCk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZmlsdGVyKGZpbGVwYXRoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gSWYgdGhlIGZpbGUgaXMgb2YgdGhlIHJpZ2h0IHR5cGUgYW5kIGV4aXN0cywgdGhpcyBzaG91bGQgd29yay5cclxuICAgICAgICAgIHJldHVybiBmcy5zdGF0U3luYyhmaWxlcGF0aClbb3B0aW9ucy5maWx0ZXJdKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoKGUpIHtcclxuICAgICAgICAvLyBPdGhlcndpc2UsIGl0J3MgcHJvYmFibHkgbm90IHRoZSByaWdodCB0eXBlLlxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHJldHVybiBtYXRjaGVzO1xyXG59O1xyXG5cclxuLy8gQnVpbGQgYSBtdWx0aSB0YXNrIFwiZmlsZXNcIiBvYmplY3QgZHluYW1pY2FsbHkuXHJcbmZpbGUuZXhwYW5kTWFwcGluZyA9IGZ1bmN0aW9uKHBhdHRlcm5zLCBkZXN0QmFzZSwgb3B0aW9ucykge1xyXG4gIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcclxuICAgIHJlbmFtZTogZnVuY3Rpb24oZGVzdEJhc2UsIGRlc3RQYXRoKSB7XHJcbiAgICAgIHJldHVybiBwYXRoLmpvaW4oZGVzdEJhc2UgfHwgJycsIGRlc3RQYXRoKTtcclxuICAgIH1cclxuICB9LCBvcHRpb25zKTtcclxuICB2YXIgZmlsZXMgPSBbXTtcclxuICB2YXIgZmlsZUJ5RGVzdCA9IHt9O1xyXG4gIC8vIEZpbmQgYWxsIGZpbGVzIG1hdGNoaW5nIHBhdHRlcm4sIHVzaW5nIHBhc3NlZC1pbiBvcHRpb25zLlxyXG4gIGZpbGUuZXhwYW5kKG9wdGlvbnMsIHBhdHRlcm5zKS5mb3JFYWNoKGZ1bmN0aW9uKHNyYykge1xyXG4gICAgdmFyIGRlc3RQYXRoID0gc3JjO1xyXG4gICAgLy8gRmxhdHRlbj9cclxuICAgIGlmIChvcHRpb25zLmZsYXR0ZW4pIHtcclxuICAgICAgZGVzdFBhdGggPSBwYXRoLmJhc2VuYW1lKGRlc3RQYXRoKTtcclxuICAgIH1cclxuICAgIC8vIENoYW5nZSB0aGUgZXh0ZW5zaW9uP1xyXG4gICAgaWYgKG9wdGlvbnMuZXh0KSB7XHJcbiAgICAgIGRlc3RQYXRoID0gZGVzdFBhdGgucmVwbGFjZSgvKFxcLlteXFwvXSopPyQvLCBvcHRpb25zLmV4dCk7XHJcbiAgICB9XHJcbiAgICAvLyBHZW5lcmF0ZSBkZXN0aW5hdGlvbiBmaWxlbmFtZS5cclxuICAgIHZhciBkZXN0ID0gb3B0aW9ucy5yZW5hbWUoZGVzdEJhc2UsIGRlc3RQYXRoLCBvcHRpb25zKTtcclxuICAgIC8vIFByZXBlbmQgY3dkIHRvIHNyYyBwYXRoIGlmIG5lY2Vzc2FyeS5cclxuICAgIGlmIChvcHRpb25zLmN3ZCkgeyBzcmMgPSBwYXRoLmpvaW4ob3B0aW9ucy5jd2QsIHNyYyk7IH1cclxuICAgIC8vIE5vcm1hbGl6ZSBmaWxlcGF0aHMgdG8gYmUgdW5peC1zdHlsZS5cclxuICAgIGRlc3QgPSBkZXN0LnJlcGxhY2UocGF0aFNlcGFyYXRvclJlLCAnLycpO1xyXG4gICAgc3JjID0gc3JjLnJlcGxhY2UocGF0aFNlcGFyYXRvclJlLCAnLycpO1xyXG4gICAgLy8gTWFwIGNvcnJlY3Qgc3JjIHBhdGggdG8gZGVzdCBwYXRoLlxyXG4gICAgaWYgKGZpbGVCeURlc3RbZGVzdF0pIHtcclxuICAgICAgLy8gSWYgZGVzdCBhbHJlYWR5IGV4aXN0cywgcHVzaCB0aGlzIHNyYyBvbnRvIHRoYXQgZGVzdCdzIHNyYyBhcnJheS5cclxuICAgICAgZmlsZUJ5RGVzdFtkZXN0XS5zcmMucHVzaChzcmMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBzcmMtZGVzdCBmaWxlIG1hcHBpbmcgb2JqZWN0LlxyXG4gICAgICBmaWxlcy5wdXNoKHtcclxuICAgICAgICBzcmM6IFtzcmNdLFxyXG4gICAgICAgIGRlc3Q6IGRlc3QsXHJcbiAgICAgIH0pO1xyXG4gICAgICAvLyBBbmQgc3RvcmUgYSByZWZlcmVuY2UgZm9yIGxhdGVyIHVzZS5cclxuICAgICAgZmlsZUJ5RGVzdFtkZXN0XSA9IGZpbGVzW2ZpbGVzLmxlbmd0aCAtIDFdO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHJldHVybiBmaWxlcztcclxufTtcclxuXHJcbi8vIHJldXNpbmcgYml0cyBvZiBncnVudCdzIG11bHRpLXRhc2sgc291cmNlIG5vcm1hbGl6YXRpb25cclxuZmlsZS5ub3JtYWxpemVGaWxlc0FycmF5ID0gZnVuY3Rpb24oZGF0YSkge1xyXG4gIHZhciBmaWxlcyA9IFtdO1xyXG5cclxuICBkYXRhLmZvckVhY2goZnVuY3Rpb24ob2JqKSB7XHJcbiAgICB2YXIgcHJvcDtcclxuICAgIGlmICgnc3JjJyBpbiBvYmogfHwgJ2Rlc3QnIGluIG9iaikge1xyXG4gICAgICBmaWxlcy5wdXNoKG9iaik7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIGlmIChmaWxlcy5sZW5ndGggPT09IDApIHtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcblxyXG4gIGZpbGVzID0gXyhmaWxlcykuY2hhaW4oKS5mb3JFYWNoKGZ1bmN0aW9uKG9iaikge1xyXG4gICAgaWYgKCEoJ3NyYycgaW4gb2JqKSB8fCAhb2JqLnNyYykgeyByZXR1cm47IH1cclxuICAgIC8vIE5vcm1hbGl6ZSAuc3JjIHByb3BlcnRpZXMgdG8gZmxhdHRlbmVkIGFycmF5LlxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqLnNyYykpIHtcclxuICAgICAgb2JqLnNyYyA9IGZsYXR0ZW4ob2JqLnNyYyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBvYmouc3JjID0gW29iai5zcmNdO1xyXG4gICAgfVxyXG4gIH0pLm1hcChmdW5jdGlvbihvYmopIHtcclxuICAgIC8vIEJ1aWxkIG9wdGlvbnMgb2JqZWN0LCByZW1vdmluZyB1bndhbnRlZCBwcm9wZXJ0aWVzLlxyXG4gICAgdmFyIGV4cGFuZE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvYmopO1xyXG4gICAgZGVsZXRlIGV4cGFuZE9wdGlvbnMuc3JjO1xyXG4gICAgZGVsZXRlIGV4cGFuZE9wdGlvbnMuZGVzdDtcclxuXHJcbiAgICAvLyBFeHBhbmQgZmlsZSBtYXBwaW5ncy5cclxuICAgIGlmIChvYmouZXhwYW5kKSB7XHJcbiAgICAgIHJldHVybiBmaWxlLmV4cGFuZE1hcHBpbmcob2JqLnNyYywgb2JqLmRlc3QsIGV4cGFuZE9wdGlvbnMpLm1hcChmdW5jdGlvbihtYXBPYmopIHtcclxuICAgICAgICAvLyBDb3B5IG9iaiBwcm9wZXJ0aWVzIHRvIHJlc3VsdC5cclxuICAgICAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqKTtcclxuICAgICAgICAvLyBNYWtlIGEgY2xvbmUgb2YgdGhlIG9yaWcgb2JqIGF2YWlsYWJsZS5cclxuICAgICAgICByZXN1bHQub3JpZyA9IE9iamVjdC5hc3NpZ24oe30sIG9iaik7XHJcbiAgICAgICAgLy8gU2V0IC5zcmMgYW5kIC5kZXN0LCBwcm9jZXNzaW5nIGJvdGggYXMgdGVtcGxhdGVzLlxyXG4gICAgICAgIHJlc3VsdC5zcmMgPSBtYXBPYmouc3JjO1xyXG4gICAgICAgIHJlc3VsdC5kZXN0ID0gbWFwT2JqLmRlc3Q7XHJcbiAgICAgICAgLy8gUmVtb3ZlIHVud2FudGVkIHByb3BlcnRpZXMuXHJcbiAgICAgICAgWydleHBhbmQnLCAnY3dkJywgJ2ZsYXR0ZW4nLCAncmVuYW1lJywgJ2V4dCddLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xyXG4gICAgICAgICAgZGVsZXRlIHJlc3VsdFtwcm9wXTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDb3B5IG9iaiBwcm9wZXJ0aWVzIHRvIHJlc3VsdCwgYWRkaW5nIGFuIC5vcmlnIHByb3BlcnR5LlxyXG4gICAgdmFyIHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oe30sIG9iaik7XHJcbiAgICAvLyBNYWtlIGEgY2xvbmUgb2YgdGhlIG9yaWcgb2JqIGF2YWlsYWJsZS5cclxuICAgIHJlc3VsdC5vcmlnID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqKTtcclxuXHJcbiAgICBpZiAoJ3NyYycgaW4gcmVzdWx0KSB7XHJcbiAgICAgIC8vIEV4cG9zZSBhbiBleHBhbmQtb24tZGVtYW5kIGdldHRlciBtZXRob2QgYXMgLnNyYy5cclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwgJ3NyYycsIHtcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gZm4oKSB7XHJcbiAgICAgICAgICB2YXIgc3JjO1xyXG4gICAgICAgICAgaWYgKCEoJ3Jlc3VsdCcgaW4gZm4pKSB7XHJcbiAgICAgICAgICAgIHNyYyA9IG9iai5zcmM7XHJcbiAgICAgICAgICAgIC8vIElmIHNyYyBpcyBhbiBhcnJheSwgZmxhdHRlbiBpdC4gT3RoZXJ3aXNlLCBtYWtlIGl0IGludG8gYW4gYXJyYXkuXHJcbiAgICAgICAgICAgIHNyYyA9IEFycmF5LmlzQXJyYXkoc3JjKSA/IGZsYXR0ZW4oc3JjKSA6IFtzcmNdO1xyXG4gICAgICAgICAgICAvLyBFeHBhbmQgc3JjIGZpbGVzLCBtZW1vaXppbmcgcmVzdWx0LlxyXG4gICAgICAgICAgICBmbi5yZXN1bHQgPSBmaWxlLmV4cGFuZChleHBhbmRPcHRpb25zLCBzcmMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIGZuLnJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICgnZGVzdCcgaW4gcmVzdWx0KSB7XHJcbiAgICAgIHJlc3VsdC5kZXN0ID0gb2JqLmRlc3Q7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9KS5mbGF0dGVuKCkudmFsdWUoKTtcclxuXHJcbiAgcmV0dXJuIGZpbGVzO1xyXG59O1xyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/archiver-utils@2.1.0/node_modules/archiver-utils/file.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/archiver-utils@2.1.0/node_modules/archiver-utils/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/archiver-utils@2.1.0/node_modules/archiver-utils/index.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\r\n * archiver-utils\r\n *\r\n * Copyright (c) 2015 Chris Talkington.\r\n * Licensed under the MIT license.\r\n * https://github.com/archiverjs/archiver-utils/blob/master/LICENSE\r\n */\r\nvar fs = __webpack_require__(/*! graceful-fs */ \"(ssr)/./node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/graceful-fs.js\");\r\nvar path = __webpack_require__(/*! path */ \"path\");\r\nvar nutil = __webpack_require__(/*! util */ \"util\");\r\nvar lazystream = __webpack_require__(/*! lazystream */ \"(ssr)/./node_modules/.pnpm/lazystream@1.0.1/node_modules/lazystream/lib/lazystream.js\");\r\nvar normalizePath = __webpack_require__(/*! normalize-path */ \"(ssr)/./node_modules/.pnpm/normalize-path@3.0.0/node_modules/normalize-path/index.js\");\r\nvar defaults = __webpack_require__(/*! lodash.defaults */ \"(ssr)/./node_modules/.pnpm/lodash.defaults@4.2.0/node_modules/lodash.defaults/index.js\");\r\n\r\nvar Stream = (__webpack_require__(/*! stream */ \"stream\").Stream);\r\nvar PassThrough = (__webpack_require__(/*! readable-stream */ \"(ssr)/./node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/readable.js\").PassThrough);\r\n\r\nvar utils = module.exports = {};\r\nutils.file = __webpack_require__(/*! ./file.js */ \"(ssr)/./node_modules/.pnpm/archiver-utils@2.1.0/node_modules/archiver-utils/file.js\");\r\n\r\nfunction assertPath(path) {\r\n  if (typeof path !== 'string') {\r\n    throw new TypeError('Path must be a string. Received ' + nutils.inspect(path));\r\n  }\r\n}\r\n\r\nutils.collectStream = function(source, callback) {\r\n  var collection = [];\r\n  var size = 0;\r\n\r\n  source.on('error', callback);\r\n\r\n  source.on('data', function(chunk) {\r\n    collection.push(chunk);\r\n    size += chunk.length;\r\n  });\r\n\r\n  source.on('end', function() {\r\n    var buf = new Buffer(size);\r\n    var offset = 0;\r\n\r\n    collection.forEach(function(data) {\r\n      data.copy(buf, offset);\r\n      offset += data.length;\r\n    });\r\n\r\n    callback(null, buf);\r\n  });\r\n};\r\n\r\nutils.dateify = function(dateish) {\r\n  dateish = dateish || new Date();\r\n\r\n  if (dateish instanceof Date) {\r\n    dateish = dateish;\r\n  } else if (typeof dateish === 'string') {\r\n    dateish = new Date(dateish);\r\n  } else {\r\n    dateish = new Date();\r\n  }\r\n\r\n  return dateish;\r\n};\r\n\r\n// this is slightly different from lodash version\r\nutils.defaults = function(object, source, guard) {\r\n  var args = arguments;\r\n  args[0] = args[0] || {};\r\n\r\n  return defaults(...args);\r\n};\r\n\r\nutils.isStream = function(source) {\r\n  return source instanceof Stream;\r\n};\r\n\r\nutils.lazyReadStream = function(filepath) {\r\n  return new lazystream.Readable(function() {\r\n    return fs.createReadStream(filepath);\r\n  });\r\n};\r\n\r\nutils.normalizeInputSource = function(source) {\r\n  if (source === null) {\r\n    return new Buffer(0);\r\n  } else if (typeof source === 'string') {\r\n    return new Buffer(source);\r\n  } else if (utils.isStream(source) && !source._readableState) {\r\n    var normalized = new PassThrough();\r\n    source.pipe(normalized);\r\n\r\n    return normalized;\r\n  }\r\n\r\n  return source;\r\n};\r\n\r\nutils.sanitizePath = function(filepath) {\r\n  return normalizePath(filepath, false).replace(/^\\w+:/, '').replace(/^(\\.\\.\\/|\\/)+/, '');\r\n};\r\n\r\nutils.trailingSlashIt = function(str) {\r\n  return str.slice(-1) !== '/' ? str + '/' : str;\r\n};\r\n\r\nutils.unixifyPath = function(filepath) {\r\n  return normalizePath(filepath, false).replace(/^\\w+:/, '');\r\n};\r\n\r\nutils.walkdir = function(dirpath, base, callback) {\r\n  var results = [];\r\n\r\n  if (typeof base === 'function') {\r\n    callback = base;\r\n    base = dirpath;\r\n  }\r\n\r\n  fs.readdir(dirpath, function(err, list) {\r\n    var i = 0;\r\n    var file;\r\n    var filepath;\r\n\r\n    if (err) {\r\n      return callback(err);\r\n    }\r\n\r\n    (function next() {\r\n      file = list[i++];\r\n\r\n      if (!file) {\r\n        return callback(null, results);\r\n      }\r\n\r\n      filepath = path.join(dirpath, file);\r\n\r\n      fs.stat(filepath, function(err, stats) {\r\n        results.push({\r\n          path: filepath,\r\n          relative: path.relative(base, filepath).replace(/\\\\/g, '/'),\r\n          stats: stats\r\n        });\r\n\r\n        if (stats && stats.isDirectory()) {\r\n          utils.walkdir(filepath, base, function(err, res) {\r\n            res.forEach(function(dirEntry) {\r\n              results.push(dirEntry);\r\n            });\r\n            next();\r\n          });\r\n        } else {\r\n          next();\r\n        }\r\n      });\r\n    })();\r\n  });\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYXJjaGl2ZXItdXRpbHNAMi4xLjAvbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxtQkFBTyxDQUFDLDBHQUFhO0FBQzlCLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixZQUFZLG1CQUFPLENBQUMsa0JBQU07QUFDMUIsaUJBQWlCLG1CQUFPLENBQUMseUdBQVk7QUFDckMsb0JBQW9CLG1CQUFPLENBQUMsNEdBQWdCO0FBQzVDLGVBQWUsbUJBQU8sQ0FBQywrR0FBaUI7QUFDeEM7QUFDQSxhQUFhLG9EQUF3QjtBQUNyQyxrQkFBa0IscUpBQXNDO0FBQ3hEO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsc0dBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsZW5pYVxcRG93bmxvYWRzXFxUb29scGFkLTJcXG5vZGVfbW9kdWxlc1xcLnBucG1cXGFyY2hpdmVyLXV0aWxzQDIuMS4wXFxub2RlX21vZHVsZXNcXGFyY2hpdmVyLXV0aWxzXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogYXJjaGl2ZXItdXRpbHNcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDE1IENocmlzIFRhbGtpbmd0b24uXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cclxuICogaHR0cHM6Ly9naXRodWIuY29tL2FyY2hpdmVyanMvYXJjaGl2ZXItdXRpbHMvYmxvYi9tYXN0ZXIvTElDRU5TRVxyXG4gKi9cclxudmFyIGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKTtcclxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XHJcbnZhciBudXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcclxudmFyIGxhenlzdHJlYW0gPSByZXF1aXJlKCdsYXp5c3RyZWFtJyk7XHJcbnZhciBub3JtYWxpemVQYXRoID0gcmVxdWlyZSgnbm9ybWFsaXplLXBhdGgnKTtcclxudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnbG9kYXNoLmRlZmF1bHRzJyk7XHJcblxyXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJykuU3RyZWFtO1xyXG52YXIgUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKS5QYXNzVGhyb3VnaDtcclxuXHJcbnZhciB1dGlscyA9IG1vZHVsZS5leHBvcnRzID0ge307XHJcbnV0aWxzLmZpbGUgPSByZXF1aXJlKCcuL2ZpbGUuanMnKTtcclxuXHJcbmZ1bmN0aW9uIGFzc2VydFBhdGgocGF0aCkge1xyXG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BhdGggbXVzdCBiZSBhIHN0cmluZy4gUmVjZWl2ZWQgJyArIG51dGlscy5pbnNwZWN0KHBhdGgpKTtcclxuICB9XHJcbn1cclxuXHJcbnV0aWxzLmNvbGxlY3RTdHJlYW0gPSBmdW5jdGlvbihzb3VyY2UsIGNhbGxiYWNrKSB7XHJcbiAgdmFyIGNvbGxlY3Rpb24gPSBbXTtcclxuICB2YXIgc2l6ZSA9IDA7XHJcblxyXG4gIHNvdXJjZS5vbignZXJyb3InLCBjYWxsYmFjayk7XHJcblxyXG4gIHNvdXJjZS5vbignZGF0YScsIGZ1bmN0aW9uKGNodW5rKSB7XHJcbiAgICBjb2xsZWN0aW9uLnB1c2goY2h1bmspO1xyXG4gICAgc2l6ZSArPSBjaHVuay5sZW5ndGg7XHJcbiAgfSk7XHJcblxyXG4gIHNvdXJjZS5vbignZW5kJywgZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihzaXplKTtcclxuICAgIHZhciBvZmZzZXQgPSAwO1xyXG5cclxuICAgIGNvbGxlY3Rpb24uZm9yRWFjaChmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgIGRhdGEuY29weShidWYsIG9mZnNldCk7XHJcbiAgICAgIG9mZnNldCArPSBkYXRhLmxlbmd0aDtcclxuICAgIH0pO1xyXG5cclxuICAgIGNhbGxiYWNrKG51bGwsIGJ1Zik7XHJcbiAgfSk7XHJcbn07XHJcblxyXG51dGlscy5kYXRlaWZ5ID0gZnVuY3Rpb24oZGF0ZWlzaCkge1xyXG4gIGRhdGVpc2ggPSBkYXRlaXNoIHx8IG5ldyBEYXRlKCk7XHJcblxyXG4gIGlmIChkYXRlaXNoIGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgZGF0ZWlzaCA9IGRhdGVpc2g7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0ZWlzaCA9PT0gJ3N0cmluZycpIHtcclxuICAgIGRhdGVpc2ggPSBuZXcgRGF0ZShkYXRlaXNoKTtcclxuICB9IGVsc2Uge1xyXG4gICAgZGF0ZWlzaCA9IG5ldyBEYXRlKCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZGF0ZWlzaDtcclxufTtcclxuXHJcbi8vIHRoaXMgaXMgc2xpZ2h0bHkgZGlmZmVyZW50IGZyb20gbG9kYXNoIHZlcnNpb25cclxudXRpbHMuZGVmYXVsdHMgPSBmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgZ3VhcmQpIHtcclxuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcclxuICBhcmdzWzBdID0gYXJnc1swXSB8fCB7fTtcclxuXHJcbiAgcmV0dXJuIGRlZmF1bHRzKC4uLmFyZ3MpO1xyXG59O1xyXG5cclxudXRpbHMuaXNTdHJlYW0gPSBmdW5jdGlvbihzb3VyY2UpIHtcclxuICByZXR1cm4gc291cmNlIGluc3RhbmNlb2YgU3RyZWFtO1xyXG59O1xyXG5cclxudXRpbHMubGF6eVJlYWRTdHJlYW0gPSBmdW5jdGlvbihmaWxlcGF0aCkge1xyXG4gIHJldHVybiBuZXcgbGF6eXN0cmVhbS5SZWFkYWJsZShmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBmcy5jcmVhdGVSZWFkU3RyZWFtKGZpbGVwYXRoKTtcclxuICB9KTtcclxufTtcclxuXHJcbnV0aWxzLm5vcm1hbGl6ZUlucHV0U291cmNlID0gZnVuY3Rpb24oc291cmNlKSB7XHJcbiAgaWYgKHNvdXJjZSA9PT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMCk7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJykge1xyXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc291cmNlKTtcclxuICB9IGVsc2UgaWYgKHV0aWxzLmlzU3RyZWFtKHNvdXJjZSkgJiYgIXNvdXJjZS5fcmVhZGFibGVTdGF0ZSkge1xyXG4gICAgdmFyIG5vcm1hbGl6ZWQgPSBuZXcgUGFzc1Rocm91Z2goKTtcclxuICAgIHNvdXJjZS5waXBlKG5vcm1hbGl6ZWQpO1xyXG5cclxuICAgIHJldHVybiBub3JtYWxpemVkO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHNvdXJjZTtcclxufTtcclxuXHJcbnV0aWxzLnNhbml0aXplUGF0aCA9IGZ1bmN0aW9uKGZpbGVwYXRoKSB7XHJcbiAgcmV0dXJuIG5vcm1hbGl6ZVBhdGgoZmlsZXBhdGgsIGZhbHNlKS5yZXBsYWNlKC9eXFx3KzovLCAnJykucmVwbGFjZSgvXihcXC5cXC5cXC98XFwvKSsvLCAnJyk7XHJcbn07XHJcblxyXG51dGlscy50cmFpbGluZ1NsYXNoSXQgPSBmdW5jdGlvbihzdHIpIHtcclxuICByZXR1cm4gc3RyLnNsaWNlKC0xKSAhPT0gJy8nID8gc3RyICsgJy8nIDogc3RyO1xyXG59O1xyXG5cclxudXRpbHMudW5peGlmeVBhdGggPSBmdW5jdGlvbihmaWxlcGF0aCkge1xyXG4gIHJldHVybiBub3JtYWxpemVQYXRoKGZpbGVwYXRoLCBmYWxzZSkucmVwbGFjZSgvXlxcdys6LywgJycpO1xyXG59O1xyXG5cclxudXRpbHMud2Fsa2RpciA9IGZ1bmN0aW9uKGRpcnBhdGgsIGJhc2UsIGNhbGxiYWNrKSB7XHJcbiAgdmFyIHJlc3VsdHMgPSBbXTtcclxuXHJcbiAgaWYgKHR5cGVvZiBiYXNlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICBjYWxsYmFjayA9IGJhc2U7XHJcbiAgICBiYXNlID0gZGlycGF0aDtcclxuICB9XHJcblxyXG4gIGZzLnJlYWRkaXIoZGlycGF0aCwgZnVuY3Rpb24oZXJyLCBsaXN0KSB7XHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICB2YXIgZmlsZTtcclxuICAgIHZhciBmaWxlcGF0aDtcclxuXHJcbiAgICBpZiAoZXJyKSB7XHJcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG4gICAgfVxyXG5cclxuICAgIChmdW5jdGlvbiBuZXh0KCkge1xyXG4gICAgICBmaWxlID0gbGlzdFtpKytdO1xyXG5cclxuICAgICAgaWYgKCFmaWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3VsdHMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmaWxlcGF0aCA9IHBhdGguam9pbihkaXJwYXRoLCBmaWxlKTtcclxuXHJcbiAgICAgIGZzLnN0YXQoZmlsZXBhdGgsIGZ1bmN0aW9uKGVyciwgc3RhdHMpIHtcclxuICAgICAgICByZXN1bHRzLnB1c2goe1xyXG4gICAgICAgICAgcGF0aDogZmlsZXBhdGgsXHJcbiAgICAgICAgICByZWxhdGl2ZTogcGF0aC5yZWxhdGl2ZShiYXNlLCBmaWxlcGF0aCkucmVwbGFjZSgvXFxcXC9nLCAnLycpLFxyXG4gICAgICAgICAgc3RhdHM6IHN0YXRzXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmIChzdGF0cyAmJiBzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XHJcbiAgICAgICAgICB1dGlscy53YWxrZGlyKGZpbGVwYXRoLCBiYXNlLCBmdW5jdGlvbihlcnIsIHJlcykge1xyXG4gICAgICAgICAgICByZXMuZm9yRWFjaChmdW5jdGlvbihkaXJFbnRyeSkge1xyXG4gICAgICAgICAgICAgIHJlc3VsdHMucHVzaChkaXJFbnRyeSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBuZXh0KCk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbmV4dCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KSgpO1xyXG4gIH0pO1xyXG59O1xyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/archiver-utils@2.1.0/node_modules/archiver-utils/index.js\n");

/***/ })

};
;